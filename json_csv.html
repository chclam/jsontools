<!--
Author: Chris Lam (c.lam@cbs.nl)
-->

<html>
  <head>
    <title>CBS JSON to CSV Converter</title>
  </head>
  <body class="container">
    <h1>CBS JSON to CSV Converter</h1>
    <div id="divUpload">
      <p>Please upload your JSON file.</p>
      <input id="btnUpload" type="file" accept=".json" value="Upload JSON" onchange="uploadJson()"/>
      <p id="pUploadResult"></p>
    </div>
  </body>
</html>

<script>

/*
todo: 
  * Allow the user to filter data columns that are being printed in the csv-file;
  * Allow the user to rename data columns in the csv-file (column aliases);
  * Allow the user to define an order in the data columns.
*/

function uploadJson() {
  const [file] = document.getElementById("btnUpload").files;
  const reader = new FileReader();
  let inputFilename = file.name;
  inputFilename = inputFilename.replace(".json", "");
  reader.addEventListener("load", () => {
      const jsonTree = parseJson(reader);
      const newTree = treeBuild(jsonTree);
      const jsonTabular = jsonToTabular(newTree);
      saveCsvBlob(jsonTabular, inputFilename);
  }, false);

  if (file) {
    reader.readAsText(file);
  }
}

function parseJson(reader) {
  const pUploadResult = document.getElementById("pUploadResult");
  // clear reset application states 
  // parse data to json
  let ret = null;
  try {
    ret = JSON.parse(reader.result); 
    pUploadResult.textContent = "Parse SUCCESS";
  } catch (e) {
    pUploadResult.innerHTML = `Parse FAILED: ${e}. <br>`;
    pUploadResult.innerHTML += "Please upload a valid JSON file.";
  }
  return ret;
}

function saveCsvBlob(csvText, inputFilename) {
  const a = window.document.createElement('a');
  a.href = window.URL.createObjectURL(new Blob([csvText], {type: "text/csv"}));
  a.download = `${inputFilename}.csv`;

  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// build a proper data structure to deal with the tree logic.
function treeBuild(jsonTree) {
  // Builds a simplified tree.
  const root = new Node(null, true);
  const tree = new Tree(root);

  const treeNodeMap = new WeakMap();
  treeNodeMap.set(jsonTree, root);

  const stack = [jsonTree];

  while (stack.length > 0) {
    const jsonNode = stack.pop();
    const treeNode = treeNodeMap.get(jsonNode);

    for (const dataKey in jsonNode) {

      const dataElement = jsonNode[dataKey];

      if (Array.isArray(dataElement)) {
        // dataElement is an array

        // case distinction per type
        for (let nestedKey=0; nestedKey<dataElement.length; nestedKey++) {
          const nestedElement = dataElement[nestedKey];
         // if () {
         //   // if is array // to do

         // } else 
          if ((!Array.isArray(nestedElement)) && typeof(nestedElement) === "object") {
            // if is object

            const newNode = new Node(treeNode, true);
            addNode(tree, newNode, treeNode);

            const newElement = {};

            Object.keys(nestedElement).forEach(
              (key) => {
                newElement[`${dataKey}_${key}`] = nestedElement[key];
              }
            );

            treeNodeMap.set(newElement, newNode);
            stack.push(newElement);

          } else {
            // if is a primitive value
            treeNodeMap.set(nestedElement, treeNode);
            stack.push(nestedElement);
          }
        }

      } else if (typeof(dataElement) === "object" && dataElement !== null) {
        // dataElement is an object 

        const newElement = {};
        Object.keys(dataElement).forEach(
          (key) => {
            newElement[`${dataKey}_${key}`] = dataElement[key];
          }
        );

        treeNodeMap.set(newElement, treeNode);
        stack.push(newElement);

      } else {
        // dataElement is a primitive value
        tree.uniqueCols.add(dataKey);
        treeNode.data.set(dataKey, dataElement);
      }
    }
  }
  return tree;
}

function jsonToTabular(tree) {
  /*
  In this function, we pass through the json-data twice.
  We first extract a set of unique columns found in
  the json tree "uniqueCols" and we store all its leaves in "leaves".
  Each leaf in leaves has a reference toward its parent "_node_parent", up until the root.

  Given "uniqueCols" and "leaves", we then traverse through each leaf up until
  the its root while extracting the fields in each inner node.  
  */

  // We make a hash map for each column in the json 
  // to its index in the resulting csv-file.
  const colMapping = {};
  Array.from(tree.uniqueCols).forEach(
    (col, idx) => {
      colMapping[col] = idx;
    }
  );

  let ret = Array.from(tree.uniqueCols).join(",") + "\n";

  for (const node of tree.nodes) {

    if (!node.isLeaf) continue;

    const leafStack = [node];
    const row = new Array(Array.from(tree.uniqueCols).length);

    while (leafStack.length > 0) {
      const innerNode = leafStack.pop();

      if (innerNode.parent !== null) leafStack.push(innerNode.parent);

      for (let [dataKey, nodeElement] of innerNode.data.entries()) {

        if (typeof(nodeElement) !== "object" && (nodeElement !== null)) {
          // if object field is a regular, non-iterative value

          // clean string
          nodeElement = nodeElement.replace(',', ' ');
          nodeElement = nodeElement.trim();

          const colIdx = colMapping[dataKey];
          row[colIdx] = nodeElement;
        }
      }
    }
    ret += (row.join(",") + "\n");
  }
  return ret;
}

function Tree(root) {
  this.root = root;
  this.nodes = [root];
  this.uniqueCols = new Set();
}

function Node(parent, isLeaf) {
  this.isLeaf = true;
  this.parent = parent;
  //this.children = [];
  this.data = new Map(); // data is filled as we traverse through the original json tree
}

function addNode(tree, newNode, parentNode) {
  parentNode.isLeaf = false;
  //parentNode.children.push(newNode);
  tree.nodes.push(newNode);
}

</script>
