<!--
Author: Chris Lam (c.lam@cbs.nl)
-->

<html>
  <head>
    <title>CBS JSON to CSV Converter</title>
  </head>
  <body class="container">
    <h1>CBS JSON to CSV Converter</h1>
    <div id="divUpload">
      <p>Please upload your JSON file.</p>
      <input id="btnUpload" type="file" accept=".json" value="Upload JSON" onchange="uploadJson()"/>
      <p id="pUploadResult"></p>
    </div>
  </body>
</html>

<script>

/*
todo: 
  * Allow the user to filter data columns that are being printed in the csv-file;
  * Allow the user to rename data columns in the csv-file (column aliases);
  * Allow the user to define an order in the data columns.
*/

function uploadJson() {
  const [file] = document.getElementById("btnUpload").files;
  const reader = new FileReader();
  let inputFilename = file.name;
  inputFilename = inputFilename.replace(".json", "");
  reader.addEventListener("load", () => {
      const jsonTree = parseJson(reader);
      const newTree = treeBuild(jsonTree);
      const jsonTabular = jsonToTabular(newTree);
      saveCsvBlob(jsonTabular, inputFilename);
  }, false);

  if (file) {
    reader.readAsText(file);
  }
}

function parseJson(reader) {
  const pUploadResult = document.getElementById("pUploadResult");
  // clear reset application states 
  // parse data to json
  let ret = null;
  try {
    ret = JSON.parse(reader.result); 
    pUploadResult.textContent = "Parse SUCCESS";
  } catch (e) {
    pUploadResult.innerHTML = `Parse FAILED: ${e}. <br>`;
    pUploadResult.innerHTML += "Please upload a valid JSON file.";
  }
  return ret;
}

function saveCsvBlob(csvText, inputFilename) {
  const a = window.document.createElement('a');
  a.href = window.URL.createObjectURL(new Blob([csvText], {type: "text/csv"}));
  a.download = `${inputFilename}.csv`;

  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// build a proper data structure to deal with the tree logic.
function treeBuild(jsonTree) {
  // Builds a simplified tree.
  const tree = new Tree();
  const root = addNode(tree);

  const treeNodeMap = new WeakMap();
  treeNodeMap.set(jsonTree, root);

  const jsonNodeNameMap = new WeakMap();
  const stack = [jsonTree];

  while (stack.length > 0) {
    const jsonNode = stack.pop();
    const treeNode = treeNodeMap.get(jsonNode);

    for (const dataKey in jsonNode) {

      const dataElement = jsonNode[dataKey];

      if (Array.isArray(dataElement)) {
        // dataElement is an array

        // case distinction per type
        for (let nestedKey=0; nestedKey<dataElement.length; nestedKey++) {
          const nestedElement = dataElement[nestedKey];

          if (Array.isArray(nestedElement)) {
            // todo nestedElement is an array 


          } else if (typeof(nestedElement) === "object") {
            // nestedElement is an object
            const newNode = addNode(tree, treeNode);
            newNode.name = dataKey;

            const jsonNodeName = jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey;
            jsonNodeNameMap.set(nestedElement, jsonNodeName);

            treeNodeMap.set(nestedElement, newNode);
            stack.push(nestedElement);

          } else {
            // nestedElement is a primitive value
//            treeNodeMap.set(nestedElement, treeNode);
//            stack.push(nestedElement);
            // todo

          }
        }

      } else if (typeof(dataElement) === "object" && dataElement !== null) {
        // dataElement is an object 
          const jsonNodeName = jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey;
          jsonNodeNameMap.set(dataElement, jsonNodeName);

          treeNodeMap.set(dataElement, treeNode);
          stack.push(dataElement);

      } else {
        // dataElement is a primitive value
        const colName = jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey;
        
        tree.uniqueCols.add(colName);
        treeNode.data.set(colName, dataElement);
      }
    }
  }
  return tree;
}


function jsonToTabular(tree) {
  /*
  In this function, we pass through the json-data twice.
  We first extract a set of unique columns found in
  the json tree "uniqueCols" and we store all its leaves in "leaves".
  Each leaf in leaves has a reference toward its parent "_node_parent", up until the root.

  Given "uniqueCols" and "leaves", we then traverse through each leaf up until
  the its root while extracting the fields in each inner node.  
  */

  // We make a hash map for each column in the json 
  // to its index in the resulting csv-file.
  const colMapping = new Map();
  Array.from(tree.uniqueCols).forEach(
    (col, idx) => {
      colMapping.set(col, idx);
    }
  );

  let ret = Array.from(colMapping.keys()).join(",") + "\n";

  for (const node of tree.nodes) {

    if (!node.isLeaf) continue;

    const leafStack = [node];
    const row = new Array(colMapping.size);

    while (leafStack.length > 0) {
      const innerNode = leafStack.pop();

      if (innerNode.parent !== null) leafStack.push(innerNode.parent);

      for (let [dataKey, nodeElement] of innerNode.data.entries()) {

        if (nodeElement === null) continue;

        // clean string
        nodeElement = nodeElement.toString();
        nodeElement = nodeElement.replace(',', ' ');
        nodeElement = nodeElement.trim();

        const colIdx = colMapping[dataKey];
        row[colIdx] = nodeElement;
      }
    }
    ret += (row.join(",") + "\n");
  }
  return ret;
}

function Tree() {
  this.root  = null;
  this.nodes = [];
  this.uniqueCols = new Set();
}

function Node() {
  this.parent = null;
  this.name   = null;
  this.isLeaf = true;
  this.children = [];

  this.data = new Map(); // data is filled as we traverse through the original json tree
}


function addNode(tree, parentNode=null) {
  const newNode = new Node();

  if (tree.nodes.length === 0) {
    console.assert(parentNode === null);
    tree.root = newNode;
  } else {
    console.assert(parentNode !== null);
    
    newNode.parent = parentNode;

    parentNode.children.push(newNode);
    parentNode.isLeaf = false;
  }

  tree.nodes.push(newNode);
  return newNode;
}

</script>
