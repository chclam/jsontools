<!--
Author: Chris Lam (c.lam@cbs.nl)
-->
<html>
  <head>
    <title>CBS JSON to CSV Converter</title>
  </head>
  <body>
    <div id="content">
      <h1>CBS JSON to CSV Converter</h1>
      <div id="divUpload">
        <input id="btnUpload" type="file" accept=".json" value="Upload JSON" onchange="viewUploadJson()"/>
        <p id="pUploadResult"></p>
        <div id="divConversionOptions" hidden>
          <button type="button" id="btnSelectAll" class="btnSecondary" onclick="{ viewSetAllCheckboxes(true); return false; }">Select All</button>
          <button type="button" id="btnDeSelectAll" class="btnSecondary" onclick="{ viewSetAllCheckboxes(false); return false; }">Deselect All</button>
          <ul id="ulColumns">
          </ul>
        </div>
      </div>
      <div id="divDownload" hidden>
        <a href id="btnDownload"><button onclick="{ viewGenerateCsv(); return false; }">Download CSV</button></a>
        <p id="pDownloadFilename"></p>
      </div>
    </div>
  </body>
</html>

<script>
/*
done: 
  * Handle empty json files. 
  * The columns are the other way around;

todo: 
  1. Filter out empty columns
  2. Allow the user to rename data columns in the csv-file (column aliases);
  3. Allow the user to select data columns that are being printed in the csv-file;
  4. Bring order to columns by column groups;
  5. Allow the user to deselect the empty columns;
  6. Sort the columns by whether it is empty or not;
  7. Some initial statistics about the input file when uploaded.

maybe:
  8. Onderscheidsteken: Allow the user to define the delimiter
  9. Volgorde: Allow the user to define an order in the data columns. OPTIONAL
*/

const csvDelimiter = ";";

let prunedTree;
let inputFilename;

/*#######*/
/* Views */
/*#######*/

function viewUploadJson() {
  const [file] = document.getElementById("btnUpload").files;
  const reader = new FileReader();
  inputFilename = file.name;
  inputFilename = inputFilename.replace(".json", "");
  reader.addEventListener("load", () => {
    // todo: reset download button?
    const jsonTree = parseJson(reader);

    if (jsonTree !== null) {
      // build a new pruned tree from the obtained json tree
      // and show the checkboxes
      prunedTree = treeBuild(jsonTree);
      viewDrawColCheckboxes(prunedTree.nodes);

      // show download button
      const divDownload = document.getElementById("divDownload");
      divDownload.removeAttribute("hidden");
    }
  }, false);

  if (file) {
    reader.readAsText(file);
  }
}

function viewDrawColCheckboxes(treeNodes, clearExisting=true) {
  const checkAllByDefault = true;

  // We assigned a name to each node in the tree.
  // We use these names to represent the "column categories".
  const uniqueNodeNames = new Set();
  for (const node of treeNodes) {
    if (node.parent !== null) {
      uniqueNodeNames.add(node.name); // do not add checkbox if it is a root
    }
  }

  const ulColumns = document.getElementById("ulColumns");

  if (clearExisting) ulColumns.innerHTML = "";

  // Add a checkbox for each unique node name.
  // The user can then select the column categories (node names)
  // that gets converted into csv.
  for (const checkboxVal of uniqueNodeNames) {
    uniqueNodeNames.add(checkboxVal);

    // add checkboxes themselves
    const checkboxColInput = document.createElement("input");
    checkboxColInput.setAttribute("type" , "checkbox");
    checkboxColInput.setAttribute("class", "CheckboxCol");
    checkboxColInput.setAttribute("id"   , `CheckboxCol_${checkboxVal}`);
    checkboxColInput.setAttribute("name" , checkboxVal);
    checkboxColInput.setAttribute("value", checkboxVal);
    checkboxColInput.checked = checkAllByDefault;

    // add checkbox labels
    const checkboxColLabel = document.createElement("label");
    const checkboxText = document.createTextNode(checkboxVal);
    checkboxColLabel.setAttribute("for", checkboxVal);
    checkboxColLabel.appendChild(checkboxText);
    checkboxColLabel.appendChild(document.createElement("br"));
    checkboxColLabel.addEventListener("click", () => {checkboxColInput.checked = !checkboxColInput.checked});

    const checkboxColLi = document.createElement("li");
    checkboxColLi.appendChild(checkboxColInput);
    checkboxColLi.appendChild(checkboxColLabel);
    ulColumns.appendChild(checkboxColLi);
  }

  // show the div
  const divConvOpts = document.getElementById("divConversionOptions");
  divConvOpts.removeAttribute("hidden");
}

function viewGenerateCsv() {
  // Get selected checkboxes
  const selectedCols = [];
  {
    const allCheckBoxes = document.querySelectorAll(".checkboxCol");
    // todo: checked attribute is not removed / added by clicking.
    // manually add an eventlistener
    for (const checkbox of allCheckBoxes) {
      if (checkbox.checked) {
        selectedCols.push(checkbox.value);
      }
    }
  }

  if (selectedCols.length === 0) {
    console.log("No columns selected!");
    return;
  } 

  const csvLines = jsonToTabular(prunedTree, selectedCols);
  saveCsvBlob(csvLines, inputFilename);
}

function viewSetAllCheckboxes(newState) {
  console.assert(typeof(newState) == "boolean");
  const allCheckBoxes = document.querySelectorAll(".checkBoxCol");
  for (const checkbox of allCheckBoxes) {
    checkbox.checked = newState;
  }
}


/*#######*/
/* Logic */
/*#######*/

function parseJson(reader) {
  const pUploadResult = document.getElementById("pUploadResult");
  // clear reset application states 
  // parse data to json
  let ret = null;

  try {
    ret = JSON.parse(reader.result); 
  } catch (e) {
    pUploadResult.innerHTML = `Parse FAILED: ${e}.<br>`;
    pUploadResult.innerHTML += "Please upload a valid JSON file.";
  }

  if (ret === null) {
    pUploadResult.innerHTML = "Empty JSON-file!<br>";
    pUploadResult.innerHTML += "No CSV-file created";
  } else {
    pUploadResult.textContent = "Parse SUCCESS";
  }
  return ret;
}


function saveCsvBlob(csvLines, inputFilename) {
  const a = document.createElement("a");
  const outputFilename = `${inputFilename}.csv`;

  a.href = window.URL.createObjectURL(new Blob(csvLines, {type: "text/csv"}));
  a.download = outputFilename;

  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}


function treeBuild(jsonTree) {
  /* We build our own tree from the source json-tree.
  The new tree is a simplified version of the source json-tree by
  "unnesting" nested objects in the source json-tree. 
  Suppose that object b is a variable under the name a in some object
  Then we add all variables of object b to object a and prefix the variables with the name of object b.
  E.g. {a: {b: 1}, c: 2} becomes {a_b:1, c: 2}.
      However, when dealing with objects in arrays, we do make add new nodes for each Object in an array.
  This is because these correspond to multiple entries belonging to the parent node.
  e.g. {a: [{b: 1}, {b: 2}], c: 2} becomes {c: 2} with children {a_b: 1} and {a_b: 2}.
  */
  const tree = new Tree();
  const root = addNode(tree);

  const treeNodeMap = new WeakMap();
  treeNodeMap.set(jsonTree, root);

  // jsonNodeNameMap maps the Node-object to the node name.
  // We use it to keep track of the parent prefixes from the original tree for the node names in the new tree.
  // Example: if we have {A: {B: 1, C: 2}, B: 3} in the old tree and we want to have {A_B: 1, A_C: 2, B: 3} in the new tree,
  // then jsonNodeNameMap keeps track of the "A_" prefix as we build the new tree.
  const jsonNodeNameMap = new WeakMap();
  const queue = [jsonTree];

  while (queue.length > 0) {
    const jsonNode = queue.shift();
    const treeNode = treeNodeMap.get(jsonNode);

    // Loop through the elements in the json node
    for (const dataKey in jsonNode) {

      const dataElement = jsonNode[dataKey];

      // case distinction per type
      if (Array.isArray(dataElement)) {
        // dataElement is an array
        for (let nestedKey=0; nestedKey<dataElement.length; nestedKey++) {
          const nestedElement = dataElement[nestedKey];

          if (Array.isArray(nestedElement)) {
            // nestedElement is an array 

            // this is an ugly case. Since an array can also 
            // contain other objects etc., we copy the array into a new object.
            const newObject = new Object();
            newObject[nestedKey] = nestedElement;

            const jsonNodeName = (jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey);
            jsonNodeNameMap.set(newObject, jsonNodeName);

            const newNode = addNode(tree, treeNode);
            newNode.name = jsonNodeName;

            treeNodeMap.set(newObject, newNode);
            queue.push(newObject);

          } else if (typeof(nestedElement) === "object") {
            // nestedElement is an object
            const newNode = addNode(tree, treeNode);
            newNode.name = dataKey;

            const jsonNodeName = jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey;
            jsonNodeNameMap.set(nestedElement, jsonNodeName);

            treeNodeMap.set(nestedElement, newNode);
            queue.push(nestedElement);

          } else {
            // nestedElement is a primitive value
            const colName = (jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey) + "_values";

            const newNode = addNode(tree, treeNode);
            newNode.name = colName;
            newNode.data.set(colName, nestedElement)
          }
        }

      } else if (typeof(dataElement) === "object" && dataElement !== null) {
        // dataElement is an object 
          const jsonNodeName = jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey;
          jsonNodeNameMap.set(dataElement, jsonNodeName);

          treeNodeMap.set(dataElement, treeNode);
          queue.push(dataElement);

      } else {
        // dataElement is a primitive value
        const colName = jsonNodeNameMap.has(jsonNode) ? `${jsonNodeNameMap.get(jsonNode)}_${dataKey}` : dataKey;
        treeNode.data.set(colName, dataElement);
      }
    }
  }
  return tree;
}

function jsonToTabular(tree, selectedNodes) {
  /* Given a simplified tree from treeBuild, we traverse the tree from the root to the leaves.
  We write a line in the resulting csv-file for each unique path from root to leaf. 
  Since the paths to the leaves often share inner nodes, we cache the row data for each
  inner node in a mapping (nodeRowCache). */

  // colMapping is a hash map for each column 
  // to its index in the resulting csv-file.
  const colMapping = new Map();
  {
    // @speed, excessive dereferencing
    let colIdx = 0;
    for (const node of tree.nodes) {
      // root of the tree is always printed in the csv-file.
      if (node.parent !== null && !selectedNodes.includes(node.name)) continue;

      for (const colName of node.data.keys()) { 
        if (!colMapping.has(colName)) {
          colMapping.set(colName, colIdx); 
          colIdx++;
        }
      }
    }
  }

  const ret = [];
  const headerRow = Array.from(colMapping.keys()).join(csvDelimiter) + "\n";
  ret.push(headerRow);

  const stack = [tree.root];
  const nodeRowCache = new WeakMap();

  while (stack.length > 0) {
    const treeNode = stack.pop(); 

    // Variable row is an array where each index correponds to a column.
    // We retrieve the cached row data for each visited inner node.
    let row;
    if (treeNode.parent === null) {
      row = new Array(colMapping.size);
    } else {
      row = [...nodeRowCache.get(treeNode.parent)]; // copy array from cache
    }
    
    // Fill row with column data
    for (let [dataKey, nodeElement] of treeNode.data.entries()) {

      if (nodeElement === null) continue; // we don't write nulls to the excel file!
      if (!colMapping.has(dataKey)) continue; // skip if not in selected columns

      // data sanitization 
      nodeElement = nodeElement.toString();
      nodeElement = nodeElement.replace("\"", "\"\"");
      nodeElement = nodeElement.trim();
      if (nodeElement.includes(csvDelimiter)) nodeElement = `\"${nodeElement}\"`;

      const colIdx = colMapping.get(dataKey);
      row[colIdx] = nodeElement;
    }

    if (treeNode.isLeaf) {
      const isEmptyRow = row.every((x) => x === undefined);
      if (!isEmptyRow) {
        const csvRow = row.join(csvDelimiter) + "\n";
        ret.push(csvRow);
      }
    } else {
      // Cache the row array that belongs to the tree node.
      nodeRowCache.set(treeNode, row); 

      for (const childNode of treeNode.children) {
        stack.push(childNode);
      }
    }
  }
  return ret;
}


function Tree() {
  this.root  = null;
  this.nodes = [];
}

function Node() {
  this.parent = null;
  this.name   = null;
  this.isLeaf = true;
  this.children = [];
  this.data = new Map(); // data is filled as we traverse through the original json tree
}

function addNode(tree, parentNode=null) {
  const newNode = new Node();

  if (tree.nodes.length === 0) {
    console.assert(parentNode === null);
    tree.root = newNode;
  } else {
    console.assert(parentNode !== null);
    
    newNode.parent = parentNode;

    parentNode.children.push(newNode);
    parentNode.isLeaf = false;
  }

  tree.nodes.push(newNode);
  return newNode;
}
</script>

<style>
  h1 {
    color: rgb(39, 29, 108);
    font-size: 36px;
  }

  h2 {
    color: rgb(9, 29, 35);
    font-size: 20px;
  }
  
  body {
    font-family: helvetica, arial, sans-serif;
    background-color: rgb(233, 233, 233);
    color: rgb(9, 29, 35);
    font-size: 16px;
  }

  button, input::file-selector-button {
    border-color: rgb(0, 161, 205);
    background-color: rgb(5, 128, 161);
    color: rgb(255, 255, 255);
    padding: 10px 10px;
  }

  button {
    border-color: rgb(0, 161, 205);
    background-color: rgb(5, 128, 161);
    color: rgb(255, 255, 255);
  }

  ul {
    list-style: none;
  }

  /* Classes */
  .btnSecondary {
    background-color: rgb(189, 188, 188);
    border-color: rgb(233, 233, 233);
    color: rgb(9, 29, 35);
  }

  /* Ids */
  #content {
    background-color: rgb(255, 255, 255);

    margin-left : 10%;
    margin-right: 10%;

    padding: 5px 20px;
  }

</style>
